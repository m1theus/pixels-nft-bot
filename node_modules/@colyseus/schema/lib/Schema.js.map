{"version":3,"file":"Schema.js","sourceRoot":"","sources":["../src/Schema.ts"],"names":[],"mappings":"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","sourcesContent":["import { SWITCH_TO_STRUCTURE, TYPE_ID, OPERATION } from './spec';\nimport { ClientWithSessionId, PrimitiveType, Context, SchemaDefinition, DefinitionType } from \"./annotations\";\n\nimport * as encode from \"./encoding/encode\";\nimport * as decode from \"./encoding/decode\";\nimport type { Iterator } from \"./encoding/decode\"; // dts-bundle-generator\n\nimport { ArraySchema } from \"./types/ArraySchema\";\nimport { MapSchema } from \"./types/MapSchema\";\nimport { CollectionSchema } from './types/CollectionSchema';\nimport { SetSchema } from './types/SetSchema';\n\nimport { ChangeTree, Ref, ChangeOperation } from \"./changes/ChangeTree\";\nimport { NonFunctionPropNames, ToJSON } from './types/HelperTypes';\nimport { ClientState } from './filters';\nimport { getType } from './types/typeRegistry';\nimport { ReferenceTracker } from './changes/ReferenceTracker';\nimport { addCallback, spliceOne } from './types/utils';\n\nexport interface DataChange<T=any,F=string> {\n    refId: number,\n    op: OPERATION,\n    field: F;\n    dynamicIndex?: number | string;\n    value: T;\n    previousValue: T;\n}\n\nexport interface SchemaDecoderCallbacks<TValue=any, TKey=any> {\n    $callbacks: { [operation: number]: Array<(item: TValue, key: TKey) => void> };\n\n    onAdd(callback: (item: any, key: any) => void, ignoreExisting?: boolean): () => void;\n    onRemove(callback: (item: any, key: any) => void): () => void;\n    onChange(callback: (item: any, key: any) => void): () => void;\n\n    clone(decoding?: boolean): SchemaDecoderCallbacks;\n    clear(changes?: DataChange[]);\n    decode?(byte, it: Iterator);\n}\n\nclass EncodeSchemaError extends Error {}\n\nfunction assertType(value: any, type: string, klass: Schema, field: string | number) {\n    let typeofTarget: string;\n    let allowNull: boolean = false;\n\n    switch (type) {\n        case \"number\":\n        case \"int8\":\n        case \"uint8\":\n        case \"int16\":\n        case \"uint16\":\n        case \"int32\":\n        case \"uint32\":\n        case \"int64\":\n        case \"uint64\":\n        case \"float32\":\n        case \"float64\":\n            typeofTarget = \"number\";\n            if (isNaN(value)) {\n                console.log(`trying to encode \"NaN\" in ${klass.constructor.name}#${field}`);\n            }\n            break;\n        case \"string\":\n            typeofTarget = \"string\";\n            allowNull = true;\n            break;\n        case \"boolean\":\n            // boolean is always encoded as true/false based on truthiness\n            return;\n    }\n\n    if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {\n        let foundValue = `'${JSON.stringify(value)}'${(value && value.constructor && ` (${value.constructor.name})`) || ''}`;\n        throw new EncodeSchemaError(`a '${typeofTarget}' was expected, but ${foundValue} was provided in ${klass.constructor.name}#${field}`);\n    }\n}\n\nfunction assertInstanceType(\n    value: Schema,\n    type: typeof Schema\n        | typeof ArraySchema\n        | typeof MapSchema\n        | typeof CollectionSchema\n        | typeof SetSchema,\n    klass: Schema,\n    field: string | number,\n) {\n    if (!(value instanceof type)) {\n        throw new EncodeSchemaError(`a '${type.name}' was expected, but '${(value as any).constructor.name}' was provided in ${klass.constructor.name}#${field}`);\n    }\n}\n\nfunction encodePrimitiveType(\n    type: PrimitiveType,\n    bytes: number[],\n    value: any,\n    klass: Schema,\n    field: string | number,\n) {\n    assertType(value, type as string, klass, field);\n\n    const encodeFunc = encode[type as string];\n\n    if (encodeFunc) {\n        encodeFunc(bytes, value);\n\n    } else {\n        throw new EncodeSchemaError(`a '${type}' was expected, but ${value} was provided in ${klass.constructor.name}#${field}`);\n    }\n}\n\nfunction decodePrimitiveType (type: string, bytes: number[], it: Iterator) {\n    return decode[type as string](bytes, it);\n}\n\n/**\n * Schema encoder / decoder\n */\nexport abstract class Schema {\n    static _typeid: number;\n    static _context: Context;\n\n    static _definition: SchemaDefinition = SchemaDefinition.create();\n\n    static onError(e) {\n        console.error(e);\n    }\n\n    static is(type: DefinitionType) {\n        return (\n            type['_definition'] &&\n            type['_definition'].schema !== undefined\n        );\n    }\n\n    protected $changes: ChangeTree;\n\n    // TODO: refactor. this feature needs to be ported to other languages with potentially different API\n    // protected $listeners: { [field: string]: Array<(value: any, previousValue: any) => void> };\n    protected $callbacks: { [op: number]: Array<Function> };\n\n    public onChange(callback: () => void): () => void {\n        return addCallback((this.$callbacks || (this.$callbacks = {})), OPERATION.REPLACE, callback);\n    }\n    public onRemove(callback: () => void): () => void {\n        return addCallback((this.$callbacks || (this.$callbacks = {})), OPERATION.DELETE, callback);\n    }\n\n    // allow inherited classes to have a constructor\n    constructor(...args: any[]) {\n        // fix enumerability of fields for end-user\n        Object.defineProperties(this, {\n            $changes: {\n                value: new ChangeTree(this, undefined, new ReferenceTracker()),\n                enumerable: false,\n                writable: true\n            },\n\n            // $listeners: {\n            //     value: undefined,\n            //     enumerable: false,\n            //     writable: true\n            // },\n\n            $callbacks: {\n                value: undefined,\n                enumerable: false,\n                writable: true\n            },\n        });\n\n        const descriptors = this._definition.descriptors;\n        if (descriptors) {\n            Object.defineProperties(this, descriptors);\n        }\n\n        //\n        // Assign initial values\n        //\n        if (args[0]) {\n            this.assign(args[0]);\n        }\n    }\n\n    public assign(\n        props: { [prop in NonFunctionPropNames<this>]?: this[prop] } | ToJSON<this>,\n    ) {\n        Object.assign(this, props);\n        return this;\n    }\n\n    protected get _definition () { return (this.constructor as typeof Schema)._definition; }\n\n    /**\n     * (Server-side): Flag a property to be encoded for the next patch.\n     * @param instance Schema instance\n     * @param property string representing the property name, or number representing the index of the property.\n     * @param operation OPERATION to perform (detected automatically)\n     */\n    public setDirty<K extends NonFunctionPropNames<this>>(property: K | number, operation?: OPERATION) {\n        this.$changes.change(property as any, operation);\n    }\n\n    /**\n     * Client-side: listen for changes on property.\n     * @param prop the property name\n     * @param callback callback to be triggered on property change\n     * @param immediate trigger immediatelly if property has been already set.\n     */\n    public listen<K extends NonFunctionPropNames<this>>(\n        prop: K,\n        callback: (value: this[K], previousValue: this[K]) => void,\n        immediate: boolean = true,\n    ) {\n        if (!this.$callbacks) { this.$callbacks = {}; }\n        if (!this.$callbacks[prop as string]) { this.$callbacks[prop as string] = []; }\n\n        this.$callbacks[prop as string].push(callback);\n\n        if (immediate && this[prop] !== undefined) {\n            callback(this[prop], undefined);\n        }\n\n        // return un-register callback.\n        return () => spliceOne(this.$callbacks[prop as string], this.$callbacks[prop as string].indexOf(callback));\n    }\n\n    decode(\n        bytes: number[],\n        it: Iterator = { offset: 0 },\n        ref: Ref = this,\n    ) {\n        const allChanges: DataChange[] = [];\n\n        const $root = this.$changes.root;\n        const totalBytes = bytes.length;\n\n        let refId: number = 0;\n        $root.refs.set(refId, this);\n\n        while (it.offset < totalBytes) {\n            let byte = bytes[it.offset++];\n\n            if (byte == SWITCH_TO_STRUCTURE) {\n                refId = decode.number(bytes, it);\n                const nextRef = $root.refs.get(refId) as Schema;\n\n                //\n                // Trying to access a reference that haven't been decoded yet.\n                //\n                if (!nextRef) { throw new Error(`\"refId\" not found: ${refId}`); }\n                ref = nextRef;\n\n                continue;\n            }\n\n            const changeTree: ChangeTree = ref['$changes'];\n            const isSchema = (ref['_definition'] !== undefined);\n\n            const operation = (isSchema)\n                ? (byte >> 6) << 6 // \"compressed\" index + operation\n                : byte; // \"uncompressed\" index + operation (array/map items)\n\n            if (operation === OPERATION.CLEAR) {\n                //\n                // TODO: refactor me!\n                // The `.clear()` method is calling `$root.removeRef(refId)` for\n                // each item inside this collection\n                //\n                (ref as SchemaDecoderCallbacks).clear(allChanges);\n                continue;\n            }\n\n            const fieldIndex = (isSchema)\n                ? byte % (operation || 255) // if \"REPLACE\" operation (0), use 255\n                : decode.number(bytes, it);\n\n            const fieldName = (isSchema)\n                ? (ref['_definition'].fieldsByIndex[fieldIndex])\n                : \"\";\n\n            let type = changeTree.getType(fieldIndex);\n            let value: any;\n            let previousValue: any;\n\n            let dynamicIndex: number | string;\n\n            if (!isSchema) {\n                previousValue = ref['getByIndex'](fieldIndex);\n\n                if ((operation & OPERATION.ADD) === OPERATION.ADD) { // ADD or DELETE_AND_ADD\n                    dynamicIndex = (ref instanceof MapSchema)\n                        ? decode.string(bytes, it)\n                        : fieldIndex;\n                    ref['setIndex'](fieldIndex, dynamicIndex);\n\n                } else {\n                    // here\n                    dynamicIndex = ref['getIndex'](fieldIndex);\n                }\n\n            } else {\n                previousValue = ref[`_${fieldName}`];\n            }\n\n            //\n            // Delete operations\n            //\n            if ((operation & OPERATION.DELETE) === OPERATION.DELETE)\n            {\n                if (operation !== OPERATION.DELETE_AND_ADD) {\n                    ref['deleteByIndex'](fieldIndex);\n                }\n\n                // Flag `refId` for garbage collection.\n                if (previousValue && previousValue['$changes']) {\n                    $root.removeRef(previousValue['$changes'].refId);\n                }\n\n                value = null;\n            }\n\n            if (fieldName === undefined) {\n                console.warn(\"@colyseus/schema: definition mismatch\");\n\n                //\n                // keep skipping next bytes until reaches a known structure\n                // by local decoder.\n                //\n                const nextIterator: Iterator = { offset: it.offset };\n                while (it.offset < totalBytes) {\n                    if (decode.switchStructureCheck(bytes, it)) {\n                        nextIterator.offset = it.offset + 1;\n                        if ($root.refs.has(decode.number(bytes, nextIterator))) {\n                            break;\n                        }\n                    }\n\n                    it.offset++;\n                }\n\n                continue;\n\n            } else if (operation === OPERATION.DELETE) {\n                //\n                // FIXME: refactor me.\n                // Don't do anything.\n                //\n\n            } else if (Schema.is(type)) {\n                const refId = decode.number(bytes, it);\n                value = $root.refs.get(refId);\n\n                if (operation !== OPERATION.REPLACE) {\n                    const childType = this.getSchemaType(bytes, it, type);\n\n                    if (!value) {\n                        value = this.createTypeInstance(childType);\n                        value.$changes.refId = refId;\n\n                        if (previousValue) {\n                            value.$callbacks = previousValue.$callbacks;\n                            // value.$listeners = previousValue.$listeners;\n\n                            if (\n                                previousValue['$changes'].refId &&\n                                refId !== previousValue['$changes'].refId\n                            ) {\n                                $root.removeRef(previousValue['$changes'].refId);\n                            }\n                        }\n                    }\n\n                    $root.addRef(refId, value, (value !== previousValue));\n                }\n            } else if (typeof(type) === \"string\") {\n                //\n                // primitive value (number, string, boolean, etc)\n                //\n                value = decodePrimitiveType(type as string, bytes, it);\n\n            } else {\n                const typeDef = getType(Object.keys(type)[0]);\n                const refId = decode.number(bytes, it);\n\n                const valueRef: SchemaDecoderCallbacks = ($root.refs.has(refId))\n                    ? previousValue || $root.refs.get(refId)\n                    : new typeDef.constructor();\n\n                value = valueRef.clone(true);\n                value.$changes.refId = refId;\n\n                // preserve schema callbacks\n                if (previousValue) {\n                    value['$callbacks'] = previousValue['$callbacks'];\n\n                    if (\n                        previousValue['$changes'].refId &&\n                        refId !== previousValue['$changes'].refId\n                    ) {\n                        $root.removeRef(previousValue['$changes'].refId);\n\n                        //\n                        // Trigger onRemove if structure has been replaced.\n                        //\n                        const entries: IterableIterator<[any, any]> = previousValue.entries();\n                        let iter: IteratorResult<[any, any]>;\n                        while ((iter = entries.next()) && !iter.done) {\n                            const [key, value] = iter.value;\n                            allChanges.push({\n                                refId,\n                                op: OPERATION.DELETE,\n                                field: key,\n                                value: undefined,\n                                previousValue: value,\n                            });\n                        }\n                    }\n                }\n\n                $root.addRef(refId, value, (valueRef !== previousValue));\n            }\n\n            if (\n                value !== null &&\n                value !== undefined\n            ) {\n                if (value['$changes']) {\n                    value['$changes'].setParent(\n                        changeTree.ref,\n                        changeTree.root,\n                        fieldIndex,\n                    );\n                }\n\n                if (ref instanceof Schema) {\n                    ref[fieldName] = value;\n                    // ref[`_${fieldName}`] = value;\n\n                } else if (ref instanceof MapSchema) {\n                    // const key = ref['$indexes'].get(field);\n                    const key = dynamicIndex as string;\n\n                    // ref.set(key, value);\n                    ref['$items'].set(key, value);\n                    ref['$changes'].allChanges.add(fieldIndex);\n\n                } else if (ref instanceof ArraySchema) {\n                    // const key = ref['$indexes'][field];\n                    // console.log(\"SETTING FOR ArraySchema =>\", { field, key, value });\n                    // ref[key] = value;\n                    ref.setAt(fieldIndex, value);\n\n                } else if (ref instanceof CollectionSchema) {\n                    const index = ref.add(value);\n                    ref['setIndex'](fieldIndex, index);\n\n                } else if (ref instanceof SetSchema) {\n                    const index = ref.add(value);\n                    if (index !== false) {\n                        ref['setIndex'](fieldIndex, index);\n                    }\n                }\n            }\n\n            if (previousValue !== value) {\n                allChanges.push({\n                    refId,\n                    op: operation,\n                    field: fieldName,\n                    dynamicIndex,\n                    value,\n                    previousValue,\n                });\n            }\n        }\n\n        this._triggerChanges(allChanges);\n\n        // drop references of unused schemas\n        $root.garbageCollectDeletedRefs();\n\n        return allChanges;\n    }\n\n    encode(\n        encodeAll = false,\n        bytes: number[] = [],\n        useFilters: boolean = false,\n    ) {\n        const rootChangeTree = this.$changes;\n        const refIdsVisited = new WeakSet<ChangeTree>();\n\n        const changeTrees: ChangeTree[] = [rootChangeTree];\n        let numChangeTrees = 1;\n\n        for (let i = 0; i < numChangeTrees; i++) {\n            const changeTree = changeTrees[i];\n            const ref = changeTree.ref;\n            const isSchema = (ref instanceof Schema);\n\n            // Generate unique refId for the ChangeTree.\n            changeTree.ensureRefId();\n\n            // mark this ChangeTree as visited.\n            refIdsVisited.add(changeTree);\n\n            // root `refId` is skipped.\n            if (\n                changeTree !== rootChangeTree &&\n                (changeTree.changed || encodeAll)\n            ) {\n                encode.uint8(bytes, SWITCH_TO_STRUCTURE);\n                encode.number(bytes, changeTree.refId);\n            }\n\n            const changes: ChangeOperation[] | number[] = (encodeAll)\n                ? Array.from(changeTree.allChanges)\n                : Array.from(changeTree.changes.values());\n\n            for (let j = 0, cl = changes.length; j < cl; j++) {\n                const operation: ChangeOperation = (encodeAll)\n                    ? { op: OPERATION.ADD, index: changes[j] as number }\n                    : changes[j] as ChangeOperation;\n\n                const fieldIndex = operation.index;\n\n                const field = (isSchema)\n                    ? ref['_definition'].fieldsByIndex && ref['_definition'].fieldsByIndex[fieldIndex]\n                    : fieldIndex;\n\n                // cache begin index if `useFilters`\n                const beginIndex = bytes.length;\n\n                // encode field index + operation\n                if (operation.op !== OPERATION.TOUCH) {\n                    if (isSchema) {\n                        //\n                        // Compress `fieldIndex` + `operation` into a single byte.\n                        // This adds a limitaion of 64 fields per Schema structure\n                        //\n                        encode.uint8(bytes, (fieldIndex | operation.op));\n\n                    } else {\n                        encode.uint8(bytes, operation.op);\n\n                        // custom operations\n                        if (operation.op === OPERATION.CLEAR) {\n                            continue;\n                        }\n\n                        // indexed operations\n                        encode.number(bytes, fieldIndex);\n                    }\n                }\n\n                //\n                // encode \"alias\" for dynamic fields (maps)\n                //\n                if (\n                    !isSchema &&\n                    (operation.op & OPERATION.ADD) == OPERATION.ADD // ADD or DELETE_AND_ADD\n                ) {\n                    if (ref instanceof MapSchema) {\n                        //\n                        // MapSchema dynamic key\n                        //\n                        const dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                        encode.string(bytes, dynamicIndex);\n                    }\n                }\n\n                if (operation.op === OPERATION.DELETE) {\n                    //\n                    // TODO: delete from filter cache data.\n                    //\n                    // if (useFilters) {\n                    //     delete changeTree.caches[fieldIndex];\n                    // }\n                    continue;\n                }\n\n                // const type = changeTree.childType || ref._schema[field];\n                const type = changeTree.getType(fieldIndex);\n\n                // const type = changeTree.getType(fieldIndex);\n                const value = changeTree.getValue(fieldIndex);\n\n                // Enqueue ChangeTree to be visited\n                if (\n                    value &&\n                    value['$changes'] &&\n                    !refIdsVisited.has(value['$changes'])\n                ) {\n                    changeTrees.push(value['$changes']);\n                    value['$changes'].ensureRefId();\n                    numChangeTrees++;\n                }\n\n                if (operation.op === OPERATION.TOUCH) {\n                    continue;\n                }\n\n                if (Schema.is(type)) {\n                    assertInstanceType(value, type as typeof Schema, ref as Schema, field);\n\n                    //\n                    // Encode refId for this instance.\n                    // The actual instance is going to be encoded on next `changeTree` iteration.\n                    //\n                    encode.number(bytes, value.$changes.refId);\n\n                    // Try to encode inherited TYPE_ID if it's an ADD operation.\n                    if ((operation.op & OPERATION.ADD) === OPERATION.ADD) {\n                        this.tryEncodeTypeId(bytes, type as typeof Schema, value.constructor as typeof Schema);\n                    }\n\n                } else if (typeof(type) === \"string\") {\n                    //\n                    // Primitive values\n                    //\n                    encodePrimitiveType(type as PrimitiveType, bytes, value, ref as Schema, field);\n\n                } else {\n                    //\n                    // Custom type (MapSchema, ArraySchema, etc)\n                    //\n                    const definition = getType(Object.keys(type)[0]);\n\n                    //\n                    // ensure a ArraySchema has been provided\n                    //\n                    assertInstanceType(ref[`_${field}`], definition.constructor, ref as Schema, field);\n\n                    //\n                    // Encode refId for this instance.\n                    // The actual instance is going to be encoded on next `changeTree` iteration.\n                    //\n                    encode.number(bytes, value.$changes.refId);\n                }\n\n                if (useFilters) {\n                    // cache begin / end index\n                    changeTree.cache(fieldIndex as number, bytes.slice(beginIndex));\n                }\n            }\n\n            if (!encodeAll && !useFilters) {\n                changeTree.discard();\n            }\n        }\n\n        return bytes;\n    }\n\n    encodeAll (useFilters?: boolean) {\n        return this.encode(true, [], useFilters);\n    }\n\n    applyFilters(client: ClientWithSessionId, encodeAll: boolean = false) {\n        const root = this;\n        const refIdsDissallowed = new Set<number>();\n\n        const $filterState = ClientState.get(client);\n\n        const changeTrees = [this.$changes];\n        let numChangeTrees = 1;\n\n        let filteredBytes: number[] = [];\n\n        for (let i = 0; i < numChangeTrees; i++) {\n            const changeTree = changeTrees[i];\n\n            if (refIdsDissallowed.has(changeTree.refId))  {\n                // console.log(\"REFID IS NOT ALLOWED. SKIP.\", { refId: changeTree.refId })\n                continue;\n            }\n\n            const ref = changeTree.ref as Ref;\n            const isSchema: boolean = ref instanceof Schema;\n\n            encode.uint8(filteredBytes, SWITCH_TO_STRUCTURE);\n            encode.number(filteredBytes, changeTree.refId);\n\n            const clientHasRefId = $filterState.refIds.has(changeTree);\n            const isEncodeAll = (encodeAll || !clientHasRefId);\n\n            // console.log(\"REF:\", ref.constructor.name);\n            // console.log(\"Encode all?\", isEncodeAll);\n\n            //\n            // include `changeTree` on list of known refIds by this client.\n            //\n            $filterState.addRefId(changeTree);\n\n            const containerIndexes = $filterState.containerIndexes.get(changeTree)\n            const changes = (isEncodeAll)\n                ? Array.from(changeTree.allChanges)\n                : Array.from(changeTree.changes.values());\n\n            //\n            // WORKAROUND: tries to re-evaluate previously not included @filter() attributes\n            // - see \"DELETE a field of Schema\" test case.\n            //\n            if (\n                !encodeAll &&\n                isSchema &&\n                (ref as Schema)._definition.indexesWithFilters\n            ) {\n                const indexesWithFilters = (ref as Schema)._definition.indexesWithFilters;\n                indexesWithFilters.forEach(indexWithFilter => {\n                    if (\n                        !containerIndexes.has(indexWithFilter) &&\n                        changeTree.allChanges.has(indexWithFilter)\n                    ) {\n                        if (isEncodeAll) {\n                            changes.push(indexWithFilter as any);\n\n                        } else {\n                            changes.push({ op: OPERATION.ADD, index: indexWithFilter, } as any);\n                        }\n                    }\n                });\n            }\n\n            for (let j = 0, cl = changes.length; j < cl; j++) {\n                const change: ChangeOperation = (isEncodeAll)\n                    ? { op: OPERATION.ADD, index: changes[j] as number }\n                    : changes[j] as ChangeOperation;\n\n                // custom operations\n                if (change.op === OPERATION.CLEAR) {\n                    encode.uint8(filteredBytes, change.op);\n                    continue;\n                }\n\n                const fieldIndex = change.index;\n\n                //\n                // Deleting fields: encode the operation + field index\n                //\n                if (change.op === OPERATION.DELETE) {\n                    //\n                    // DELETE operations also need to go through filtering.\n                    //\n                    // TODO: cache the previous value so we can access the value (primitive or `refId`)\n                    // (check against `$filterState.refIds`)\n                    //\n\n                    if (isSchema) {\n                        encode.uint8(filteredBytes, change.op | fieldIndex);\n\n                    } else {\n                        encode.uint8(filteredBytes, change.op);\n                        encode.number(filteredBytes, fieldIndex);\n\n                    }\n                    continue;\n                }\n\n                // indexed operation\n                const value = changeTree.getValue(fieldIndex);\n                const type = changeTree.getType(fieldIndex);\n\n                if (isSchema) {\n                    // Is a Schema!\n                    const filter = (\n                        (ref as Schema)._definition.filters &&\n                        (ref as Schema)._definition.filters[fieldIndex]\n                    );\n\n                    if (filter && !filter.call(ref, client, value, root)) {\n                        if (value && value['$changes']) {\n                            refIdsDissallowed.add(value['$changes'].refId);;\n                        }\n                        continue;\n                    }\n\n                } else {\n                    // Is a collection! (map, array, etc.)\n                    const parent = changeTree.parent as Ref;\n                    const filter = changeTree.getChildrenFilter();\n\n                    if (filter && !filter.call(parent, client, ref['$indexes'].get(fieldIndex), value, root)) {\n                        if (value && value['$changes']) {\n                            refIdsDissallowed.add(value['$changes'].refId);\n                        }\n                        continue;\n                    }\n                }\n\n                // visit child ChangeTree on further iteration.\n                if (value['$changes']) {\n                    changeTrees.push(value['$changes']);\n                    numChangeTrees++;\n                }\n\n                //\n                // Copy cached bytes\n                //\n                if (change.op !== OPERATION.TOUCH) {\n\n                    //\n                    // TODO: refactor me!\n                    //\n\n                    if (change.op === OPERATION.ADD || isSchema) {\n                        //\n                        // use cached bytes directly if is from Schema type.\n                        //\n                        filteredBytes.push.apply(filteredBytes, changeTree.caches[fieldIndex] ?? []);\n                        containerIndexes.add(fieldIndex);\n\n                    } else {\n                        if (containerIndexes.has(fieldIndex)) {\n                            //\n                            // use cached bytes if already has the field\n                            //\n                            filteredBytes.push.apply(filteredBytes, changeTree.caches[fieldIndex] ?? []);\n\n                        } else {\n                            //\n                            // force ADD operation if field is not known by this client.\n                            //\n                            containerIndexes.add(fieldIndex);\n\n                            encode.uint8(filteredBytes, OPERATION.ADD);\n                            encode.number(filteredBytes, fieldIndex);\n\n                            if (ref instanceof MapSchema) {\n                                //\n                                // MapSchema dynamic key\n                                //\n                                const dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                                encode.string(filteredBytes, dynamicIndex);\n                            }\n\n                            if (value['$changes']) {\n                                encode.number(filteredBytes, value['$changes'].refId);\n\n                            } else {\n                                // \"encodePrimitiveType\" without type checking.\n                                // the type checking has been done on the first .encode() call.\n                                encode[type as string](filteredBytes, value);\n                            }\n                        }\n                    }\n\n                } else if (value['$changes'] && !isSchema) {\n                    //\n                    // TODO:\n                    // - track ADD/REPLACE/DELETE instances on `$filterState`\n                    // - do NOT always encode dynamicIndex for MapSchema.\n                    //   (If client already has that key, only the first index is necessary.)\n                    //\n\n                    encode.uint8(filteredBytes, OPERATION.ADD);\n                    encode.number(filteredBytes, fieldIndex);\n\n                    if (ref instanceof MapSchema) {\n                        //\n                        // MapSchema dynamic key\n                        //\n                        const dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                        encode.string(filteredBytes, dynamicIndex);\n                    }\n\n                    encode.number(filteredBytes, value['$changes'].refId);\n                }\n\n            };\n        }\n\n        return filteredBytes;\n    }\n\n    clone (): this {\n        const cloned = new ((this as any).constructor);\n        const schema = this._definition.schema;\n        for (let field in schema) {\n            if (\n                typeof (this[field]) === \"object\" &&\n                typeof (this[field]?.clone) === \"function\"\n            ) {\n                // deep clone\n                cloned[field] = this[field].clone();\n\n            } else {\n                // primitive values\n                cloned[field] = this[field];\n            }\n        }\n        return cloned;\n    }\n\n    toJSON () {\n        const schema = this._definition.schema;\n        const deprecated = this._definition.deprecated;\n\n        const obj: unknown = {};\n        for (let field in schema) {\n            if (!deprecated[field] && this[field] !== null && typeof (this[field]) !== \"undefined\") {\n                obj[field] = (typeof (this[field]['toJSON']) === \"function\")\n                    ? this[field]['toJSON']()\n                    : this[`_${field}`];\n            }\n        }\n        return obj as ToJSON<typeof this>;\n    }\n\n    discardAllChanges() {\n        this.$changes.discardAll();\n    }\n\n    protected getByIndex(index: number) {\n        return this[this._definition.fieldsByIndex[index]];\n    }\n\n    protected deleteByIndex(index: number) {\n        this[this._definition.fieldsByIndex[index]] = undefined;\n    }\n\n    private tryEncodeTypeId (bytes: number[], type: typeof Schema, targetType: typeof Schema) {\n        if (type._typeid !== targetType._typeid) {\n            encode.uint8(bytes, TYPE_ID);\n            encode.number(bytes, targetType._typeid);\n        }\n    }\n\n    private getSchemaType(bytes: number[], it: Iterator, defaultType: typeof Schema): typeof Schema {\n        let type: typeof Schema;\n\n        if (bytes[it.offset] === TYPE_ID) {\n            it.offset++;\n            type = (this.constructor as typeof Schema)._context.get(decode.number(bytes, it));\n        }\n\n        return type || defaultType;\n    }\n\n    private createTypeInstance (type: typeof Schema): Schema {\n        let instance: Schema = new (type as any)();\n\n        // assign root on $changes\n        instance.$changes.root = this.$changes.root;\n\n        return instance;\n    }\n\n    private _triggerChanges(changes: DataChange[]) {\n        const uniqueRefIds = new Set<number>();\n        const $refs = this.$changes.root.refs;\n\n        for (let i = 0; i < changes.length; i++) {\n            const change = changes[i];\n            const refId = change.refId;\n            const ref = $refs.get(refId);\n            const $callbacks: Schema['$callbacks'] | SchemaDecoderCallbacks['$callbacks'] = ref['$callbacks'];\n\n            //\n            // trigger onRemove on child structure.\n            //\n            if (\n                (change.op & OPERATION.DELETE) === OPERATION.DELETE &&\n                change.previousValue instanceof Schema\n            ) {\n                change.previousValue['$callbacks']?.[OPERATION.DELETE]?.forEach(callback => callback());\n            }\n\n            // no callbacks defined, skip this structure!\n            if (!$callbacks) { continue; }\n\n            if (ref instanceof Schema) {\n                if (!uniqueRefIds.has(refId)) {\n                    try {\n                        // trigger onChange\n                        ($callbacks as Schema['$callbacks'])?.[OPERATION.REPLACE]?.forEach(callback =>\n                            callback());\n\n                    } catch (e) {\n                        Schema.onError(e);\n                    }\n                }\n\n                try {\n                    if ($callbacks.hasOwnProperty(change.field)) {\n                        $callbacks[change.field]?.forEach((callback) =>\n                            callback(change.value, change.previousValue));\n                    }\n\n                } catch (e) {\n                    Schema.onError(e);\n                }\n\n            } else {\n                // is a collection of items\n\n                if (change.op === OPERATION.ADD && change.previousValue === undefined) {\n                    // triger onAdd\n                    $callbacks[OPERATION.ADD]?.forEach(callback =>\n                        callback(change.value, change.dynamicIndex ?? change.field));\n\n                } else if (change.op === OPERATION.DELETE) {\n                    //\n                    // FIXME: `previousValue` should always be available.\n                    // ADD + DELETE operations are still encoding DELETE operation.\n                    //\n                    if (change.previousValue !== undefined) {\n                        // triger onRemove\n                        $callbacks[OPERATION.DELETE]?.forEach(callback =>\n                            callback(change.previousValue, change.dynamicIndex ?? change.field));\n                    }\n\n                } else if (change.op === OPERATION.DELETE_AND_ADD) {\n                    // triger onRemove\n                    if (change.previousValue !== undefined) {\n                        $callbacks[OPERATION.DELETE]?.forEach(callback =>\n                            callback(change.previousValue, change.dynamicIndex ?? change.field));\n                    }\n\n                    // triger onAdd\n                    $callbacks[OPERATION.ADD]?.forEach(callback =>\n                        callback(change.value, change.dynamicIndex ?? change.field));\n                }\n\n                // trigger onChange\n                if (change.value !== change.previousValue) {\n                    $callbacks[OPERATION.REPLACE]?.forEach(callback =>\n                        callback(change.value, change.dynamicIndex ?? change.field));\n                }\n            }\n\n            uniqueRefIds.add(refId);\n        }\n\n    }\n}\n"]}