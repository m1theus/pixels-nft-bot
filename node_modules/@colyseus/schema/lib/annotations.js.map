{"version":3,"file":"annotations.js","sourceRoot":"","sources":["../src/annotations.ts"],"names":[],"mappings":";;;AACA,qCAAkC;AAClC,qDAAiE;AACjE,iDAA2D;AAC3D,uDAA+C;AAgD/C,MAAa,gBAAgB;IAA7B;QAGI,EAAE;QACF,0EAA0E;QAC1E,EAAE;QAEF,YAAO,GAAgC,EAAE,CAAC;QAC1C,kBAAa,GAAgC,EAAE,CAAC;QAMhD,eAAU,GAAiC,EAAE,CAAC;QAC9C,gBAAW,GAA0C,EAAE,CAAC;IA4D5D,CAAC;IA1DG,MAAM,CAAC,MAAM,CAAC,MAAyB;QACnC,MAAM,UAAU,GAAG,IAAI,gBAAgB,EAAE,CAAC;QAE1C,sBAAsB;QACtB,UAAU,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC;QACrE,UAAU,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC;QACvE,UAAU,CAAC,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,aAAa,IAAI,EAAE,CAAC,CAAC;QACnF,UAAU,CAAC,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,WAAW,IAAI,EAAE,CAAC,CAAC;QAC/E,UAAU,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,UAAU,IAAI,EAAE,CAAC,CAAC;QAE7E,OAAO,UAAU,CAAC;IACtB,CAAC;IAED,QAAQ,CAAC,KAAa,EAAE,IAAoB;QACxC,MAAM,KAAK,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACvC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;QAClC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;QAC5B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YACtC,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE;YACpB,CAAC,CAAC,IAAI,CAAC;IACf,CAAC;IAED,QAAQ,CAAC,KAAa;QAClB,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,SAAS,CAAC;IAC7C,CAAC;IAED,SAAS,CAAC,KAAa,EAAE,EAAkB;QACvC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;YAClB,IAAI,CAAC,kBAAkB,GAAG,EAAE,CAAC;SAChC;QACD,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,CAAC;QACvC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QAClD,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,iBAAiB,CAAC,KAAa,EAAE,EAA0B;QACvD,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAClC,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAEhC,IAAI,IAAA,sBAAO,EAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;YAC/B,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;gBAAE,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;aAAE;YAEnD,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;YAC9B,OAAO,IAAI,CAAC;SAEf;aAAM;YACH,OAAO,CAAC,IAAI,CAAC,2BAA2B,KAAK,yCAAyC,CAAC,CAAC;SAC3F;IACL,CAAC;IAED,iBAAiB,CAAC,KAAa;QAC3B,OAAO,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;IACvE,CAAC;IAED,iBAAiB;QACb,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC;IACjD,CAAC;CACJ;AA3ED,4CA2EC;AAED,SAAgB,SAAS,CAAC,KAAoB;IAC1C,OAAO,KAAK,CAAC,QAAQ,IAAI,KAAK,CAAC,QAAQ,CAAC,UAAU,CAAC;AACvD,CAAC;AAFD,8BAEC;AAUD,MAAa,OAAO;IAApB;QACI,UAAK,GAAkC,EAAE,CAAC;QAC1C,YAAO,GAAG,IAAI,GAAG,EAAyB,CAAC;QAC3C,eAAU,GAAG,KAAK,CAAC;IA6BvB,CAAC;IA3BG,GAAG,CAAC,MAAqB;QACrB,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACpC,CAAC;IAED,GAAG,CAAC,MAAc;QACd,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IAC9B,CAAC;IAED,GAAG,CAAC,MAAqB,EAAE,SAAiB,IAAI,CAAC,OAAO,CAAC,IAAI;QACzD,sCAAsC;QACtC,sBAAsB;QACtB,MAAM,CAAC,WAAW,GAAG,gBAAgB,CAAC,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QAEjE,MAAM,CAAC,OAAO,GAAG,MAAM,CAAC;QACxB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;QAC5B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACrC,CAAC;IAGD,MAAM,CAAC,MAAM,CAAC,UAAuB,EAAE;QACnC,OAAO,UAAU,UAA0B;YACvC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE;gBAClB,OAAO,CAAC,OAAO,GAAG,IAAI,OAAO,EAAE,CAAC;aACnC;YACD,OAAO,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QACrC,CAAC,CAAA;IACL,CAAC;CACJ;AAhCD,0BAgCC;AAEY,QAAA,aAAa,GAAG,IAAI,OAAO,EAAE,CAAC;AAE3C;;;;;;;;;;;;;;;GAeG;AACH,SAAgB,IAAI,CAChB,IAAoB,EACpB,UAAuB,EAAE;IAEzB,OAAO,UAAU,MAAqB,EAAE,KAAa;QACjD,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,IAAI,qBAAa,CAAC;QACjD,MAAM,WAAW,GAAG,MAAM,CAAC,WAA4B,CAAC;QACxD,WAAW,CAAC,QAAQ,GAAG,OAAO,CAAC;QAE/B,IAAI,CAAC,IAAI,EAAE;YACP,MAAM,IAAI,KAAK,CAAC,GAAG,WAAW,CAAC,IAAI,qCAAqC,KAAK,qEAAqE,CAAC,CAAC;SACvJ;QAED;;WAEG;QACH,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE;YAC3B,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;SAC5B;QAED,MAAM,UAAU,GAAG,WAAW,CAAC,WAAW,CAAC;QAC3C,UAAU,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QAEjC;;WAEG;QACH,IAAI,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE;YAC/B,IAAI,UAAU,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;gBAC9B,qDAAqD;gBACrD,OAAO;aAEV;iBAAM;gBACH,oEAAoE;gBACpE,iFAAiF;gBACjF,IAAI;oBACA,MAAM,IAAI,KAAK,CAAC,gCAAgC,KAAK,oBAAoB,WAAW,CAAC,IAAI,8BAA8B,CAAC,CAAC;iBAE5H;gBAAC,OAAO,CAAC,EAAE;oBACR,MAAM,gBAAgB,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;oBACvD,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,IAAI,gBAAgB,EAAE,CAAC,CAAC;iBACvD;aACJ;SACJ;QAED,MAAM,OAAO,GAAG,yBAAW,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;QACrC,MAAM,KAAK,GAAG,CAAC,OAAO,IAAI,qBAAS,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;QAE7C,qBAAqB;QACrB,sEAAsE;QACtE,+EAA+E;QAC/E,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,QAAQ,IAAI,CAAC,eAAM,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;YAChD,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YACzC,IAAI,OAAO,CAAC,SAAS,CAAC,KAAK,QAAQ,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;gBAC5D,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;aAC1B;SACJ;QAED,IAAI,OAAO,CAAC,MAAM,EAAE;YAChB,0CAA0C;YAC1C,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG;gBAC5B,UAAU,EAAE,IAAI;gBAChB,YAAY,EAAE,IAAI;gBAClB,QAAQ,EAAE,IAAI;aACjB,CAAC;YACF,OAAO;SACV;QAED,MAAM,WAAW,GAAG,IAAI,KAAK,EAAE,CAAC;QAChC,UAAU,CAAC,WAAW,CAAC,WAAW,CAAC,GAAG;YAClC,UAAU,EAAE,KAAK;YACjB,YAAY,EAAE,KAAK;YACnB,QAAQ,EAAE,IAAI;SACjB,CAAC;QAEF,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG;YAC5B,GAAG,EAAE;gBACD,OAAO,IAAI,CAAC,WAAW,CAAC,CAAC;YAC7B,CAAC;YAED,GAAG,EAAE,UAAwB,KAAU;gBACnC;;mBAEG;gBAEH,uCAAuC;gBACvC,IAAI,KAAK,KAAK,IAAI,CAAC,WAAW,CAAC,EAAE;oBAC7B,OAAO;iBACV;gBAED,IACI,KAAK,KAAK,SAAS;oBACnB,KAAK,KAAK,IAAI,EAChB;oBACE,kDAAkD;oBAClD,IAAI,OAAO,IAAI,CAAC,CAAC,KAAK,YAAY,yBAAW,CAAC,EAAE;wBAC5C,KAAK,GAAG,IAAI,yBAAW,CAAC,GAAG,KAAK,CAAC,CAAC;qBACrC;oBAED,8CAA8C;oBAC9C,IAAI,KAAK,IAAI,CAAC,CAAC,KAAK,YAAY,qBAAS,CAAC,EAAE;wBACxC,KAAK,GAAG,IAAI,qBAAS,CAAC,KAAK,CAAC,CAAC;qBAChC;oBAED,8CAA8C;oBAC9C,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE;wBAC/B,IAAI,KAAK,EAAE;4BACP,KAAK,GAAG,IAAA,uBAAW,EAAC,KAAK,CAAC,CAAC;yBAE9B;6BAAM,IAAI,OAAO,EAAE;4BAChB,KAAK,GAAG,IAAA,2BAAa,EAAC,KAAK,CAAC,CAAC;yBAChC;qBACJ;oBAED,gCAAgC;oBAChC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;oBAE5B,EAAE;oBACF,sDAAsD;oBACtD,cAAc;oBACd,EAAE;oBACF,IAAI,KAAK,CAAC,UAAU,CAAC,EAAE;wBAClB,KAAK,CAAC,UAAU,CAAgB,CAAC,SAAS,CACvC,IAAI,EACJ,IAAI,CAAC,QAAQ,CAAC,IAAI,EAClB,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAClC,CAAC;qBACL;iBAEJ;qBAAM,IAAI,IAAI,CAAC,WAAW,CAAC,EAAE;oBAC1B,EAAE;oBACF,2DAA2D;oBAC3D,EAAE;oBACF,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBAC/B;gBAED,IAAI,CAAC,WAAW,CAAC,GAAG,KAAK,CAAC;YAC9B,CAAC;YAED,UAAU,EAAE,IAAI;YAChB,YAAY,EAAE,IAAI;SACrB,CAAC;IACN,CAAC,CAAA;AACL,CAAC;AA9ID,oBA8IC;AAED;;GAEG;AAEH,SAAgB,MAAM,CAAwC,EAA2B;IACrF,OAAO,UAAU,MAAW,EAAE,KAAa;QACvC,MAAM,WAAW,GAAG,MAAM,CAAC,WAA4B,CAAC;QACxD,MAAM,UAAU,GAAG,WAAW,CAAC,WAAW,CAAC;QAE3C,IAAI,UAAU,CAAC,SAAS,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE;YACjC,WAAW,CAAC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC;SAC1C;IACL,CAAC,CAAA;AACL,CAAC;AATD,wBASC;AAED,SAAgB,cAAc,CAA2C,EAAsC;IAC3G,OAAO,UAAU,MAAW,EAAE,KAAa;QACvC,MAAM,WAAW,GAAG,MAAM,CAAC,WAA4B,CAAC;QACxD,MAAM,UAAU,GAAG,WAAW,CAAC,WAAW,CAAC;QAC3C,IAAI,UAAU,CAAC,iBAAiB,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE;YACzC,WAAW,CAAC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC;SAC1C;IACL,CAAC,CAAA;AACL,CAAC;AARD,wCAQC;AAGD;;;GAGG;AAEH,SAAgB,UAAU,CAAC,SAAkB,IAAI;IAC7C,OAAO,UAAU,MAAqB,EAAE,KAAa;QACjD,MAAM,WAAW,GAAG,MAAM,CAAC,WAA4B,CAAC;QACxD,MAAM,UAAU,GAAG,WAAW,CAAC,WAAW,CAAC;QAE3C,UAAU,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;QAEpC,IAAI,MAAM,EAAE;YACR,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG;gBAC5B,GAAG,EAAE,cAAc,MAAM,IAAI,KAAK,CAAC,GAAG,KAAK,iBAAiB,CAAC,CAAC,CAAC,CAAC;gBAChE,GAAG,EAAE,UAAwB,KAAU,IAAsD,CAAC;gBAC9F,UAAU,EAAE,KAAK;gBACjB,YAAY,EAAE,IAAI;aACrB,CAAC;SACL;IACL,CAAC,CAAA;AACL,CAAC;AAhBD,gCAgBC;AAED,SAAgB,WAAW,CACvB,MAAqB,EACrB,MAA8C,EAC9C,UAAuB,EAAE;IAEzB,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE;QAClB,OAAO,CAAC,OAAO,GAAG,MAAM,CAAC,QAAQ,IAAI,OAAO,CAAC,OAAO,IAAI,qBAAa,CAAC;KACzE;IAED,KAAK,IAAI,KAAK,IAAI,MAAM,EAAE;QACtB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC,MAAM,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;KACzD;IACD,OAAO,MAAM,CAAC;AAClB,CAAC;AAbD,kCAaC","sourcesContent":["import { ChangeTree } from './changes/ChangeTree';\nimport { Schema } from './Schema';\nimport { ArraySchema, getArrayProxy } from './types/ArraySchema';\nimport { MapSchema, getMapProxy } from './types/MapSchema';\nimport { getType } from './types/typeRegistry';\n\n/**\n * Data types\n */\nexport type PrimitiveType =\n    \"string\" |\n    \"number\" |\n    \"boolean\" |\n    \"int8\" |\n    \"uint8\" |\n    \"int16\" |\n    \"uint16\" |\n    \"int32\" |\n    \"uint32\" |\n    \"int64\" |\n    \"uint64\" |\n    \"float32\" |\n    \"float64\" |\n    typeof Schema;\n\nexport type DefinitionType = PrimitiveType\n    | PrimitiveType[]\n    | { array: PrimitiveType }\n    | { map: PrimitiveType }\n    | { collection: PrimitiveType }\n    | { set: PrimitiveType };\n\nexport type Definition = { [field: string]: DefinitionType };\nexport type FilterCallback<\n    T extends Schema = any,\n    V = any,\n    R extends Schema = any\n> = (\n    ((this: T, client: ClientWithSessionId, value: V) => boolean) |\n    ((this: T, client: ClientWithSessionId, value: V, root: R) => boolean)\n);\n\nexport type FilterChildrenCallback<\n    T extends Schema = any,\n    K = any,\n    V = any,\n    R extends Schema = any\n> = (\n    ((this: T, client: ClientWithSessionId, key: K, value: V) => boolean) |\n    ((this: T, client: ClientWithSessionId, key: K, value: V, root: R) => boolean)\n)\n\nexport class SchemaDefinition {\n    schema: Definition;\n\n    //\n    // TODO: use a \"field\" structure combining all these properties per-field.\n    //\n\n    indexes: { [field: string]: number } = {};\n    fieldsByIndex: { [index: number]: string } = {};\n\n    filters: { [field: string]: FilterCallback };\n    indexesWithFilters: number[];\n    childFilters: { [field: string]: FilterChildrenCallback }; // childFilters are used on Map, Array, Set items.\n\n    deprecated: { [field: string]: boolean } = {};\n    descriptors: PropertyDescriptorMap & ThisType<any> = {};\n\n    static create(parent?: SchemaDefinition) {\n        const definition = new SchemaDefinition();\n\n        // support inheritance\n        definition.schema = Object.assign({}, parent && parent.schema || {});\n        definition.indexes = Object.assign({}, parent && parent.indexes || {});\n        definition.fieldsByIndex = Object.assign({}, parent && parent.fieldsByIndex || {});\n        definition.descriptors = Object.assign({}, parent && parent.descriptors || {});\n        definition.deprecated = Object.assign({}, parent && parent.deprecated || {});\n\n        return definition;\n    }\n\n    addField(field: string, type: DefinitionType) {\n        const index = this.getNextFieldIndex();\n        this.fieldsByIndex[index] = field;\n        this.indexes[field] = index;\n        this.schema[field] = (Array.isArray(type))\n            ? { array: type[0] }\n            : type;\n    }\n\n    hasField(field: string) {\n        return this.indexes[field] !== undefined;\n    }\n\n    addFilter(field: string, cb: FilterCallback) {\n        if (!this.filters) {\n            this.filters = {};\n            this.indexesWithFilters = [];\n        }\n        this.filters[this.indexes[field]] = cb;\n        this.indexesWithFilters.push(this.indexes[field]);\n        return true;\n    }\n\n    addChildrenFilter(field: string, cb: FilterChildrenCallback) {\n        const index = this.indexes[field];\n        const type = this.schema[field];\n\n        if (getType(Object.keys(type)[0])) {\n            if (!this.childFilters) { this.childFilters = {}; }\n\n            this.childFilters[index] = cb;\n            return true;\n\n        } else {\n            console.warn(`@filterChildren: field '${field}' can't have children. Ignoring filter.`);\n        }\n    }\n\n    getChildrenFilter(field: string) {\n        return this.childFilters && this.childFilters[this.indexes[field]];\n    }\n\n    getNextFieldIndex() {\n        return Object.keys(this.schema || {}).length;\n    }\n}\n\nexport function hasFilter(klass: typeof Schema) {\n    return klass._context && klass._context.useFilters;\n}\n\n// Colyseus integration\nexport type ClientWithSessionId = { sessionId: string } & any;\n\nexport interface TypeOptions {\n    manual?: boolean,\n    context?: Context,\n}\n\nexport class Context {\n    types: {[id: number]: typeof Schema} = {};\n    schemas = new Map<typeof Schema, number>();\n    useFilters = false;\n\n    has(schema: typeof Schema) {\n        return this.schemas.has(schema);\n    }\n\n    get(typeid: number) {\n        return this.types[typeid];\n    }\n\n    add(schema: typeof Schema, typeid: number = this.schemas.size) {\n        // FIXME: move this to somewhere else?\n        // support inheritance\n        schema._definition = SchemaDefinition.create(schema._definition);\n\n        schema._typeid = typeid;\n        this.types[typeid] = schema;\n        this.schemas.set(schema, typeid);\n    }\n\n\n    static create(options: TypeOptions = {}) {\n        return function (definition: DefinitionType) {\n            if (!options.context) {\n                options.context = new Context();\n            }\n            return type(definition, options);\n        }\n    }\n}\n\nexport const globalContext = new Context();\n\n/**\n * [See documentation](https://docs.colyseus.io/state/schema/)\n *\n * Annotate a Schema property to be serializeable.\n * \\@type()'d fields are automatically flagged as \"dirty\" for the next patch.\n *\n * @example Standard usage, with automatic change tracking.\n * ```\n * \\@type(\"string\") propertyName: string;\n * ```\n *\n * @example You can provide the \"manual\" option if you'd like to manually control your patches via .setDirty().\n * ```\n * \\@type(\"string\", { manual: true })\n * ```\n */\nexport function type (\n    type: DefinitionType,\n    options: TypeOptions = {}\n): PropertyDecorator {\n    return function (target: typeof Schema, field: string) {\n        const context = options.context || globalContext;\n        const constructor = target.constructor as typeof Schema;\n        constructor._context = context;\n\n        if (!type) {\n            throw new Error(`${constructor.name}: @type() reference provided for \"${field}\" is undefined. Make sure you don't have any circular dependencies.`);\n        }\n\n        /*\n         * static schema\n         */\n        if (!context.has(constructor)) {\n            context.add(constructor);\n        }\n\n        const definition = constructor._definition;\n        definition.addField(field, type);\n\n        /**\n         * skip if descriptor already exists for this field (`@deprecated()`)\n         */\n        if (definition.descriptors[field]) {\n            if (definition.deprecated[field]) {\n                // do not create accessors for deprecated properties.\n                return;\n\n            } else {\n                // trying to define same property multiple times across inheritance.\n                // https://github.com/colyseus/colyseus-unity3d/issues/131#issuecomment-814308572\n                try {\n                    throw new Error(`@colyseus/schema: Duplicate '${field}' definition on '${constructor.name}'.\\nCheck @type() annotation`);\n\n                } catch (e) {\n                    const definitionAtLine = e.stack.split(\"\\n\")[4].trim();\n                    throw new Error(`${e.message} ${definitionAtLine}`);\n                }\n            }\n        }\n\n        const isArray = ArraySchema.is(type);\n        const isMap = !isArray && MapSchema.is(type);\n\n        // TODO: refactor me.\n        // Allow abstract intermediary classes with no fields to be serialized\n        // (See \"should support an inheritance with a Schema type without fields\" test)\n        if (typeof (type) !== \"string\" && !Schema.is(type)) {\n            const childType = Object.values(type)[0];\n            if (typeof (childType) !== \"string\" && !context.has(childType)) {\n                context.add(childType);\n            }\n        }\n\n        if (options.manual) {\n            // do not declare getter/setter descriptor\n            definition.descriptors[field] = {\n                enumerable: true,\n                configurable: true,\n                writable: true,\n            };\n            return;\n        }\n\n        const fieldCached = `_${field}`;\n        definition.descriptors[fieldCached] = {\n            enumerable: false,\n            configurable: false,\n            writable: true,\n        };\n\n        definition.descriptors[field] = {\n            get: function () {\n                return this[fieldCached];\n            },\n\n            set: function (this: Schema, value: any) {\n                /**\n                 * Create Proxy for array or map items\n                 */\n\n                // skip if value is the same as cached.\n                if (value === this[fieldCached]) {\n                    return;\n                }\n\n                if (\n                    value !== undefined &&\n                    value !== null\n                ) {\n                    // automaticallty transform Array into ArraySchema\n                    if (isArray && !(value instanceof ArraySchema)) {\n                        value = new ArraySchema(...value);\n                    }\n\n                    // automaticallty transform Map into MapSchema\n                    if (isMap && !(value instanceof MapSchema)) {\n                        value = new MapSchema(value);\n                    }\n\n                    // try to turn provided structure into a Proxy\n                    if (value['$proxy'] === undefined) {\n                        if (isMap) {\n                            value = getMapProxy(value);\n\n                        } else if (isArray) {\n                            value = getArrayProxy(value);\n                        }\n                    }\n\n                    // flag the change for encoding.\n                    this.$changes.change(field);\n\n                    //\n                    // call setParent() recursively for this and its child\n                    // structures.\n                    //\n                    if (value['$changes']) {\n                        (value['$changes'] as ChangeTree).setParent(\n                            this,\n                            this.$changes.root,\n                            this._definition.indexes[field],\n                        );\n                    }\n\n                } else if (this[fieldCached]) {\n                    //\n                    // Setting a field to `null` or `undefined` will delete it.\n                    //\n                    this.$changes.delete(field);\n                }\n\n                this[fieldCached] = value;\n            },\n\n            enumerable: true,\n            configurable: true\n        };\n    }\n}\n\n/**\n * `@filter()` decorator for defining data filters per client\n */\n\nexport function filter<T extends Schema, V, R extends Schema>(cb: FilterCallback<T, V, R>): PropertyDecorator {\n    return function (target: any, field: string) {\n        const constructor = target.constructor as typeof Schema;\n        const definition = constructor._definition;\n\n        if (definition.addFilter(field, cb)) {\n            constructor._context.useFilters = true;\n        }\n    }\n}\n\nexport function filterChildren<T extends Schema, K, V, R extends Schema>(cb: FilterChildrenCallback<T, K, V, R>): PropertyDecorator {\n    return function (target: any, field: string) {\n        const constructor = target.constructor as typeof Schema;\n        const definition = constructor._definition;\n        if (definition.addChildrenFilter(field, cb)) {\n            constructor._context.useFilters = true;\n        }\n    }\n}\n\n\n/**\n * `@deprecated()` flag a field as deprecated.\n * The previous `@type()` annotation should remain along with this one.\n */\n\nexport function deprecated(throws: boolean = true): PropertyDecorator {\n    return function (target: typeof Schema, field: string) {\n        const constructor = target.constructor as typeof Schema;\n        const definition = constructor._definition;\n\n        definition.deprecated[field] = true;\n\n        if (throws) {\n            definition.descriptors[field] = {\n                get: function () { throw new Error(`${field} is deprecated.`); },\n                set: function (this: Schema, value: any) { /* throw new Error(`${field} is deprecated.`); */ },\n                enumerable: false,\n                configurable: true\n            };\n        }\n    }\n}\n\nexport function defineTypes(\n    target: typeof Schema,\n    fields: { [property: string]: DefinitionType },\n    options: TypeOptions = {}\n) {\n    if (!options.context) {\n        options.context = target._context || options.context || globalContext;\n    }\n\n    for (let field in fields) {\n        type(fields[field], options)(target.prototype, field);\n    }\n    return target;\n}\n"]}