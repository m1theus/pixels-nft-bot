{"version":3,"file":"cpp.js","sourceRoot":"","sources":["../../../src/codegen/languages/cpp.ts"],"names":[],"mappings":"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","sourcesContent":["import { Class, Property, File, getCommentHeader, getInheritanceTree, Context } from \"../types\";\nimport { GenerateOptions } from \"../api\";\n\nconst typeMaps = {\n    \"string\": \"string\",\n    \"number\": \"varint_t\",\n    \"boolean\": \"bool\",\n    \"int8\": \"int8_t\",\n    \"uint8\": \"uint8_t\",\n    \"int16\": \"int16_t\",\n    \"uint16\": \"uint16_t\",\n    \"int32\": \"int32_t\",\n    \"uint32\": \"uint32_t\",\n    \"int64\": \"int64_t\",\n    \"uint64\": \"uint64_t\",\n    \"float32\": \"float32_t\",\n    \"float64\": \"float64_t\",\n}\n\nconst typeInitializer = {\n    \"string\": '\"\"',\n    \"number\": \"0\",\n    \"boolean\": \"false\",\n    \"int8\": \"0\",\n    \"uint8\": \"0\",\n    \"int16\": \"0\",\n    \"uint16\": \"0\",\n    \"int32\": \"0\",\n    \"uint32\": \"0\",\n    \"int64\": \"0\",\n    \"uint64\": \"0\",\n    \"float32\": \"0\",\n    \"float64\": \"0\",\n}\n\n/**\n * C++ Code Generator\n */\n\nconst capitalize = (s) => {\n    if (typeof s !== 'string') return ''\n    return s.charAt(0).toUpperCase() + s.slice(1);\n}\nconst distinct = (value, index, self) => self.indexOf(value) === index;\n\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: klass.name + \".hpp\",\n        content: generateClass(klass, options.namespace, context.classes)\n    }));\n}\n\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    const propertiesPerType: {[type: string]: Property[]} = {};\n    const allRefs: Property[] = [];\n    klass.properties.forEach(property => {\n        let type = property.type;\n\n        if (!propertiesPerType[type]) {\n            propertiesPerType[type] = [];\n        }\n\n        propertiesPerType[type].push(property);\n\n        // keep all refs list\n        if ((type === \"ref\" || type === \"array\" || type === \"map\")) {\n            allRefs.push(property);\n        }\n    });\n\n    const allProperties = getAllProperties(klass, allClasses);\n    const createInstanceMethod = (allRefs.length === 0) ? \"\" :\n    `\\tinline Schema* createInstance(std::type_index type) {\n\\t\\t${generateFieldIfElseChain(allRefs,\n    (property) => `type == typeid(${property.childType})`,\n    (property) => `return new ${property.childType}();`,\n    (property) => typeMaps[property.childType] === undefined)}\n\\t\\treturn ${klass.extends}::createInstance(type);\n\\t}`;\n\n    return `${getCommentHeader()}\n#ifndef __SCHEMA_CODEGEN_${klass.name.toUpperCase()}_H__\n#define __SCHEMA_CODEGEN_${klass.name.toUpperCase()}_H__ 1\n\n#include \"schema.h\"\n#include <typeinfo>\n#include <typeindex>\n\n${allRefs.\n    filter(ref => ref.childType && typeMaps[ref.childType] === undefined).\n    map(ref => ref.childType).\n    concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).\n    filter(distinct).\n    map(childType => `#include \"${childType}.hpp\"`).\n    join(\"\\n\")}\n\nusing namespace colyseus::schema;\n\n${namespace ? `namespace ${namespace} {` : \"\"}\nclass ${klass.name} : public ${klass.extends} {\npublic:\n${klass.properties.map(prop => generateProperty(prop)).join(\"\\n\")}\n\n\\t${klass.name}() {\n\\t\\tthis->_indexes = ${generateAllIndexes(allProperties)};\n\\t\\tthis->_types = ${generateAllTypes(allProperties)};\n\\t\\tthis->_childPrimitiveTypes = ${generateAllChildPrimitiveTypes(allProperties)};\n\\t\\tthis->_childSchemaTypes = ${generateAllChildSchemaTypes(allProperties)};\n\\t}\n\n\\tvirtual ~${klass.name}() {\n\\t\\t${generateDestructors(allProperties).join(\"\\n\\t\\t\")}\n\\t}\n\nprotected:\n${Object.keys(propertiesPerType).map(type =>\n    generateGettersAndSetters(klass, type, propertiesPerType[type])).\n    join(\"\\n\")}\n\n${createInstanceMethod}\n};\n${namespace ? \"}\" : \"\"}\n\n#endif\n`;\n}\n\nfunction generateProperty(prop: Property) {\n    let property = \"\";\n    let langType: string;\n    let initializer = \"\";\n    let isPropPointer = \"\";\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if(prop.type === \"ref\") {\n            langType = `${prop.childType}`;\n            initializer = `new ${prop.childType}()`;\n\n        } else if(prop.type === \"array\") {\n            langType = (isUpcaseFirst)\n                ? `ArraySchema<${prop.childType}*>`\n                : `ArraySchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n\n        } else if(prop.type === \"map\") {\n            langType = (isUpcaseFirst)\n                ? `MapSchema<${prop.childType}*>`\n                : `MapSchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n        }\n        isPropPointer = \"*\";\n\n    } else {\n        langType = typeMaps[prop.type];\n        initializer = typeInitializer[prop.type];\n    }\n\n    property += ` ${langType} ${isPropPointer}${prop.name}`;\n\n    return `\\t${property} = ${initializer};`\n}\n\nfunction generateGettersAndSetters(klass: Class, type: string, properties: Property[]) {\n    let langType = typeMaps[type];\n    let typeCast = \"\";\n\n    const getMethodName = `get${capitalize(type)}`;\n    const setMethodName = `set${capitalize(type)}`;\n\n    if (type === \"ref\") {\n        langType = \"Schema*\";\n\n    } else if (type === \"array\") {\n        langType = `ArraySchema<char*> *`;\n        typeCast = `(ArraySchema<char*> *)`;\n\n    } else if (type === \"map\") {\n        langType = `MapSchema<char*> *`;\n        typeCast = `(MapSchema<char*> *)`;\n    }\n\n    return `\\tinline ${langType} ${getMethodName}(const string &field)\n\\t{\n\\t\\t${generateFieldIfElseChain(properties,\n    (property) => `field == \"${property.name}\"`,\n    (property) => `return ${typeCast}this->${property.name};`)}\n\\t\\treturn ${klass.extends}::${getMethodName}(field);\n\\t}\n\n\\tinline void ${setMethodName}(const string &field, ${langType} value)\n\\t{\n\\t\\t${generateFieldIfElseChain(properties,\n    (property) => `field == \"${property.name}\"`,\n    (property) => {\n        const isSchemaType = (typeMaps[property.childType] === undefined)\n\n        if (type === \"ref\") {\n            langType = `${property.childType}*`;\n            typeCast = (isSchemaType)\n                ? `(${property.childType}*)`\n                : `/* bug? */`;\n\n        } else if (type === \"array\") {\n            typeCast = (isSchemaType)\n                ? `(ArraySchema<${property.childType}*> *)`\n                : `(ArraySchema<${typeMaps[property.childType]}> *)`;\n\n        } else if (type === \"map\") {\n            typeCast = (isSchemaType)\n                ? `(MapSchema<${property.childType}*> *)`\n                : `(MapSchema<${typeMaps[property.childType]}> *)`;\n        }\n\n        return `this->${property.name} = ${typeCast}value;\\n\\t\\t\\treturn;`\n    })}\n\\t\\treturn ${klass.extends}::${setMethodName}(field, value);\n\\t}`;\n}\n\nfunction generateFieldIfElseChain(\n    properties: Property[],\n    ifCallback: (property: Property) => string,\n    callback: (property: Property) => string,\n    filter: (property: Property) => boolean = (_) => true,\n) {\n    let chain = \"\";\n\n    const uniqueChecks: string[] = [];\n    properties.filter(filter).forEach((property, i) => {\n        const check = ifCallback(property);\n        if (uniqueChecks.indexOf(check) === -1) {\n            uniqueChecks.push(check);\n\n        } else {\n            return;\n        }\n\n        if (i === 0) { chain += \"if \" } else { chain += \" else if \" }\n        chain += `(${check})\n\\t\\t{\n\\t\\t\\t${callback(property)}\\n\n\\t\\t}`\n    });\n\n    return chain;\n}\n\nfunction generateAllIndexes(properties: Property[]) {\n    return `{${properties.map((property, i) => `{${i}, \"${property.name}\"}`).join(\", \")}}`\n\n}\n\nfunction generateAllTypes(properties: Property[]) {\n    return `{${properties.map((property, i) => `{${i}, \"${property.type}\"}`).join(\", \")}}`\n}\n\nfunction generateAllChildSchemaTypes(properties: Property[]) {\n    return `{${properties.map((property, i) => {\n        if (property.childType && typeMaps[property.childType] === undefined) {\n            return `{${i}, typeid(${property.childType})}`\n        } else {\n            return null;\n        }\n    }).filter(r => r !== null).join(\", \")}}`\n}\n\nfunction generateAllChildPrimitiveTypes(properties: Property[]) {\n    return `{${properties.map((property, i) => {\n        if (typeMaps[property.childType] !== undefined) {\n            return `{${i}, \"${property.childType}\"}`\n        } else {\n            return null;\n        }\n    }).filter(r => r !== null).join(\", \")}}`\n}\n\nfunction generateDestructors(properties: Property[]) {\n    return properties.map((property, i) => {\n        if (property.childType) {\n            return `delete this->${property.name};`;\n        } else {\n            return null;\n        }\n    }).filter(r => r !== null);\n}\n\nfunction getAllProperties (klass: Class, allClasses: Class[]) {\n    let properties: Property[] = [];\n\n    getInheritanceTree(klass, allClasses).reverse().forEach((klass) => {\n        properties = properties.concat(klass.properties);\n    });\n\n    return properties;\n}"]}