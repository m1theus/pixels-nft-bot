{"version":3,"file":"lua.js","sourceRoot":"","sources":["../../../src/codegen/languages/lua.ts"],"names":[],"mappings":"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","sourcesContent":["import { Class, Property, File, getCommentHeader, getInheritanceTree, Context } from \"../types\";\nimport { GenerateOptions } from \"../api\";\n\n/**\n    TODO:\n    - Support inheritance\n    - Support importing Schema dependencies\n*/\n\nconst typeMaps = {\n    \"string\": \"string\",\n    \"number\": \"number\",\n    \"boolean\": \"boolean\",\n    \"int8\": \"number\",\n    \"uint8\": \"number\",\n    \"int16\": \"number\",\n    \"uint16\": \"number\",\n    \"int32\": \"number\",\n    \"uint32\": \"number\",\n    \"int64\": \"number\",\n    \"uint64\": \"number\",\n    \"float32\": \"number\",\n    \"float64\": \"number\",\n}\n\nconst distinct = (value, index, self) => self.indexOf(value) === index;\n\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: klass.name + \".lua\",\n        content: generateClass(klass, options.namespace, context.classes)\n    }));\n}\n\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    const allRefs: Property[] = [];\n    klass.properties.forEach(property => {\n        let type = property.type;\n\n        // keep all refs list\n        if ((type === \"ref\" || type === \"array\" || type === \"map\")) {\n            allRefs.push(property);\n        }\n    });\n\n// TOOD: inheritance\n\n    return `${getCommentHeader().replace(/\\/\\//mg, \"--\")}\n\nlocal schema = require 'colyseus.serialization.schema.schema'\n${allRefs.\n    filter(ref => ref.childType && typeMaps[ref.childType] === undefined).\n    map(ref => ref.childType).\n    concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).\n    filter(distinct).\n    map(childType => `local ${childType} = require '${(namespace ? `${namespace}.` : '')}${childType}'`).\n    join(\"\\n\")}\n\nlocal ${klass.name} = schema.define({\n${klass.properties.map(prop => generatePropertyDeclaration(prop)).join(\",\\n\")},\n    [\"_fields_by_index\"] = { ${klass.properties.map(prop => `\"${prop.name}\"`).join(\", \")} },\n})\n\nreturn ${klass.name}\n`;\n\n    // [\"on_change\"] = function(changes)\n    //     -- on change logic here\n    // end,\n\n    // [\"on_add\"] = function()\n    //     -- on add logic here\n    //  end,\n\n    // [\"on_remove\"] = function()\n    //     -- on remove logic here\n    // end,\n}\n\nfunction generatePropertyDeclaration(prop: Property) {\n    let typeArgs: string;\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if (isUpcaseFirst) {\n            typeArgs += `${prop.childType}`;\n\n        } else {\n            typeArgs += `\"${prop.childType}\"`;\n        }\n\n        if(prop.type === \"ref\") {\n            typeArgs = (isUpcaseFirst)\n                ? `${prop.childType}`\n                : `\"${prop.childType}\"`;\n\n        } else {\n            typeArgs = (isUpcaseFirst)\n                ? `{ ${prop.type} = ${prop.childType} }`\n                : `{ ${prop.type} = \"${prop.childType}\" }`;\n        }\n\n    } else {\n        typeArgs = `\"${prop.type}\"`;\n    }\n\n    return `    [\"${prop.name}\"] = ${typeArgs}`;\n}\n\n// function generatePropertyInitializer(prop: Property) {\n//     let initializer = \"\";\n\n//     if(prop.type === \"ref\") {\n//         initializer = `new ${prop.childType}()`;\n\n//     } else if(prop.type === \"array\") {\n//         initializer = `new schema.ArraySchema()`;\n\n//     } else if(prop.type === \"map\") {\n//         initializer = `new schema.MapSchema()`;\n//     }\n\n//     return `this.${prop.name} = ${initializer}`;\n// }\n"]}