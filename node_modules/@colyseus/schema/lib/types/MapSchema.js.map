{"version":3,"file":"MapSchema.js","sourceRoot":"","sources":["../../src/types/MapSchema.ts"],"names":[],"mappings":"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","sourcesContent":["import { SchemaDecoderCallbacks } from \"../Schema\";\nimport { addCallback, removeChildRefs } from \"./utils\";\nimport { DataChange } from \"..\";\nimport { ChangeTree } from \"../changes/ChangeTree\";\nimport { OPERATION } from \"../spec\";\n\nexport function getMapProxy(value: MapSchema) {\n    value['$proxy'] = true;\n\n    value = new Proxy(value, {\n        get: (obj, prop) => {\n            if (\n                typeof (prop) !== \"symbol\" && // accessing properties\n                typeof (obj[prop]) === \"undefined\"\n            ) {\n                return obj.get(prop as string);\n\n            } else {\n                return obj[prop];\n            }\n        },\n\n        set: (obj, prop, setValue) => {\n            if (\n                typeof (prop) !== \"symbol\" &&\n                (\n                    (prop as string).indexOf(\"$\") === -1 &&\n                    prop !== \"onAdd\" &&\n                    prop !== \"onRemove\" &&\n                    prop !== \"onChange\"\n                )\n            ) {\n                obj.set(prop as string, setValue);\n\n            } else {\n                obj[prop] = setValue;\n            }\n            return true;\n        },\n\n        deleteProperty: (obj, prop) => {\n            obj.delete(prop as string);\n            return true;\n        },\n    });\n\n    return value;\n}\n\nexport class MapSchema<V=any, K extends string = string> implements Map<K, V>, SchemaDecoderCallbacks {\n    protected $changes: ChangeTree = new ChangeTree(this);\n\n    protected $items: Map<K, V> = new Map<K, V>();\n    protected $indexes: Map<number, K> = new Map<number, K>();\n\n    protected $refId: number = 0;\n\n    //\n    // Decoding callbacks\n    //\n    public $callbacks: { [operation: number]: Array<(item: V, key: string) => void> };\n    public onAdd(callback: (item: V, key: string) => void, triggerAll: boolean = true) {\n        return addCallback(\n            (this.$callbacks || (this.$callbacks = {})),\n            OPERATION.ADD,\n            callback,\n            (triggerAll)\n                ? this.$items\n                : undefined\n        );\n    }\n    public onRemove(callback: (item: V, key: string) => void) { return addCallback(this.$callbacks || (this.$callbacks = {}), OPERATION.DELETE, callback); }\n    public onChange(callback: (item: V, key: string) => void) { return addCallback(this.$callbacks || (this.$callbacks = {}), OPERATION.REPLACE, callback); }\n\n    static is(type: any) {\n        return type['map'] !== undefined;\n    }\n\n    constructor (initialValues?: Map<K, V> | Record<K, V>) {\n        if (initialValues) {\n            if (\n                initialValues instanceof Map ||\n                initialValues instanceof MapSchema\n            ) {\n                initialValues.forEach((v, k) => this.set(k, v));\n\n            } else {\n                for (const k in initialValues) {\n                    this.set(k, initialValues[k]);\n                }\n            }\n        }\n    }\n\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<[K, V]> { return this.$items[Symbol.iterator](); }\n    get [Symbol.toStringTag]() { return this.$items[Symbol.toStringTag] }\n\n    static get [Symbol.species]() {\n        return MapSchema;\n    }\n\n    set(key: K, value: V) {\n        if (value === undefined || value === null) {\n            throw new Error(`MapSchema#set('${key}', ${value}): trying to set ${value} value on '${key}'.`);\n        }\n\n        // Force \"key\" as string\n        // See: https://github.com/colyseus/colyseus/issues/561#issuecomment-1646733468\n        key = key.toString() as K;\n\n        // get \"index\" for this value.\n        const hasIndex = typeof(this.$changes.indexes[key]) !== \"undefined\";\n        const index = (hasIndex)\n            ? this.$changes.indexes[key]\n            : this.$refId++;\n\n        let operation: OPERATION = (hasIndex)\n            ? OPERATION.REPLACE\n            : OPERATION.ADD;\n\n        const isRef = (value['$changes']) !== undefined;\n        if (isRef) {\n            (value['$changes'] as ChangeTree).setParent(\n                this,\n                this.$changes.root,\n                index\n            );\n        }\n\n        //\n        // (encoding)\n        // set a unique id to relate directly with this key/value.\n        //\n        if (!hasIndex) {\n            this.$changes.indexes[key] = index;\n            this.$indexes.set(index, key);\n\n        } else if (\n            !isRef &&\n            this.$items.get(key) === value\n        ) {\n            // if value is the same, avoid re-encoding it.\n            return;\n\n        } else if (\n            isRef && // if is schema, force ADD operation if value differ from previous one.\n            this.$items.get(key) !== value\n        ) {\n            operation = OPERATION.ADD;\n        }\n\n        this.$items.set(key, value);\n\n        this.$changes.change(key, operation);\n\n        return this;\n    }\n\n    get(key: K): V | undefined {\n        return this.$items.get(key);\n    }\n\n    delete(key: K) {\n        //\n        // TODO: add a \"purge\" method after .encode() runs, to cleanup removed `$indexes`\n        //\n        // We don't remove $indexes to allow setting the same key in the same patch\n        // (See \"should allow to remove and set an item in the same place\" test)\n        //\n        // // const index = this.$changes.indexes[key];\n        // // this.$indexes.delete(index);\n\n        this.$changes.delete(key);\n        return this.$items.delete(key);\n    }\n\n    clear(changes?: DataChange[]) {\n        // discard previous operations.\n        this.$changes.discard(true, true);\n        this.$changes.indexes = {};\n\n        // clear previous indexes\n        this.$indexes.clear();\n\n        //\n        // When decoding:\n        // - enqueue items for DELETE callback.\n        // - flag child items for garbage collection.\n        //\n        if (changes) {\n            removeChildRefs.call(this, changes);\n        }\n\n        // clear items\n        this.$items.clear();\n\n        this.$changes.operation({ index: 0, op: OPERATION.CLEAR });\n\n        // touch all structures until reach root\n        this.$changes.touchParents();\n    }\n\n    has (key: K) {\n        return this.$items.has(key);\n    }\n\n    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void) {\n        this.$items.forEach(callbackfn);\n    }\n\n    entries () {\n        return this.$items.entries();\n    }\n\n    keys () {\n        return this.$items.keys();\n    }\n\n    values() {\n        return this.$items.values();\n    }\n\n    get size () {\n        return this.$items.size;\n    }\n\n    protected setIndex(index: number, key: K) {\n        this.$indexes.set(index, key);\n    }\n\n    protected getIndex(index: number) {\n        return this.$indexes.get(index);\n    }\n\n    protected getByIndex(index: number) {\n        return this.$items.get(this.$indexes.get(index));\n    }\n\n    protected deleteByIndex(index: number) {\n        const key = this.$indexes.get(index);\n        this.$items.delete(key);\n        this.$indexes.delete(index);\n    }\n\n    toJSON() {\n        const map: any = {};\n\n        this.forEach((value, key) => {\n            map[key] = (typeof (value['toJSON']) === \"function\")\n                ? value['toJSON']()\n                : value;\n        });\n\n        return map;\n    }\n\n    //\n    // Decoding utilities\n    //\n    clone(isDecoding?: boolean): MapSchema<V> {\n        let cloned: MapSchema;\n\n        if (isDecoding) {\n            // client-side\n            cloned = Object.assign(new MapSchema(), this);\n\n        } else {\n            // server-side\n            cloned = new MapSchema();\n            this.forEach((value, key) => {\n                if (value['$changes']) {\n                    cloned.set(key, value['clone']());\n                } else {\n                    cloned.set(key, value);\n                }\n            })\n        }\n\n        return cloned;\n    }\n\n}\n"]}