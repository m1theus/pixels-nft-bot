{"version":3,"file":"Reflection.js","sourceRoot":"","sources":["../src/Reflection.ts"],"names":[],"mappings":"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","sourcesContent":["import { type, PrimitiveType, Context, DefinitionType } from \"./annotations\";\nimport { Schema } from \"./Schema\";\nimport { ArraySchema } from \"./types/ArraySchema\";\nimport { getType } from \"./types/typeRegistry\";\nimport { Iterator } from \"./encoding/decode\";\n\nconst reflectionContext = { context: new Context() };\n\n/**\n * Reflection\n */\nexport class ReflectionField extends Schema {\n    @type(\"string\", reflectionContext)\n    name: string;\n\n    @type(\"string\", reflectionContext)\n    type: string;\n\n    @type(\"number\", reflectionContext)\n    referencedType: number;\n}\n\nexport class ReflectionType extends Schema {\n    @type(\"number\", reflectionContext)\n    id: number;\n\n    @type([ ReflectionField ], reflectionContext)\n    fields: ArraySchema<ReflectionField> = new ArraySchema<ReflectionField>();\n}\n\nexport class Reflection extends Schema {\n    @type([ ReflectionType ], reflectionContext)\n    types: ArraySchema<ReflectionType> = new ArraySchema<ReflectionType>();\n\n    @type(\"number\", reflectionContext)\n    rootType: number;\n\n    static encode (instance: Schema) {\n        const rootSchemaType = instance.constructor as typeof Schema;\n\n        const reflection = new Reflection();\n        reflection.rootType = rootSchemaType._typeid;\n\n        const buildType = (currentType: ReflectionType, schema: any) => {\n            for (let fieldName in schema) {\n                const field = new ReflectionField();\n                field.name = fieldName;\n\n                let fieldType: string;\n\n                if (typeof (schema[fieldName]) === \"string\") {\n                    fieldType = schema[fieldName];\n\n                } else {\n                    const type = schema[fieldName];\n                    let childTypeSchema: typeof Schema;\n\n                    //\n                    // TODO: refactor below.\n                    //\n                    if (Schema.is(type)) {\n                        fieldType = \"ref\";\n                        childTypeSchema = schema[fieldName];\n\n                    } else {\n                        fieldType = Object.keys(type)[0];\n\n                        if (typeof(type[fieldType]) === \"string\") {\n                            fieldType += \":\" + type[fieldType]; // array:string\n\n                        } else {\n                            childTypeSchema = type[fieldType];\n                        }\n                    }\n\n                    field.referencedType = (childTypeSchema)\n                        ? childTypeSchema._typeid\n                        : -1;\n                }\n\n                field.type = fieldType;\n                currentType.fields.push(field);\n            }\n\n            reflection.types.push(currentType);\n        }\n\n        const types = rootSchemaType._context?.types;\n        for (let typeid in types) {\n            const type = new ReflectionType();\n            type.id = Number(typeid);\n            buildType(type, types[typeid]._definition.schema);\n        }\n\n        return reflection.encodeAll();\n    }\n\n    static decode<T extends Schema = Schema>(bytes: number[], it?: Iterator): T {\n        const context = new Context();\n\n        const reflection = new Reflection();\n        reflection.decode(bytes, it);\n\n        const schemaTypes = reflection.types.reduce((types, reflectionType) => {\n            const schema: typeof Schema = class _ extends Schema {};\n            const typeid = reflectionType.id;\n            types[typeid] = schema\n            context.add(schema, typeid);\n            return types;\n        }, {});\n\n        reflection.types.forEach((reflectionType) => {\n            const schemaType = schemaTypes[reflectionType.id];\n\n            reflectionType.fields.forEach(field => {\n                if (field.referencedType !== undefined) {\n                    let fieldType = field.type;\n                    let refType = schemaTypes[field.referencedType];\n\n                    // map or array of primitive type (-1)\n                    if (!refType) {\n                        const typeInfo = field.type.split(\":\");\n                        fieldType = typeInfo[0];\n                        refType = typeInfo[1];\n                    }\n\n                    if (fieldType === \"ref\") {\n                        type(refType, { context })(schemaType.prototype, field.name);\n\n                    } else {\n                        type({ [fieldType]: refType } as DefinitionType, { context })(schemaType.prototype, field.name);\n                    }\n\n                } else {\n                    type(field.type as PrimitiveType, { context })(schemaType.prototype, field.name);\n                }\n            });\n        })\n\n        const rootType: any = schemaTypes[reflection.rootType];\n        const rootInstance = new rootType();\n\n        /**\n         * auto-initialize referenced types on root type\n         * to allow registering listeners immediatelly on client-side\n         */\n        for (let fieldName in rootType._definition.schema) {\n            const fieldType = rootType._definition.schema[fieldName];\n\n            if (typeof(fieldType) !== \"string\") {\n                rootInstance[fieldName] = (typeof (fieldType) === \"function\")\n                    ? new (fieldType as any)() // is a schema reference\n                    : new (getType(Object.keys(fieldType)[0])).constructor(); // is a \"collection\"\n            }\n        }\n\n        return rootInstance;\n    }\n}"]}