{"version":3,"file":"ReferenceTracker.js","sourceRoot":"","sources":["../../src/changes/ReferenceTracker.ts"],"names":[],"mappings":";;;AAAA,sCAAmC;AAInC,MAAa,gBAAgB;IAA7B;QACI,EAAE;QACF,wCAAwC;QACxC,wDAAwD;QACxD,EAAE;QACK,SAAI,GAAG,IAAI,GAAG,EAAe,CAAC;QAC9B,cAAS,GAAiC,EAAE,CAAC;QAC7C,gBAAW,GAAG,IAAI,GAAG,EAAU,CAAC;QAE7B,iBAAY,GAAW,CAAC,CAAC;IA6EvC,CAAC;IA3EG,eAAe;QACX,OAAO,IAAI,CAAC,YAAY,EAAE,CAAC;IAC/B,CAAC;IAED,eAAe;IACf,MAAM,CAAC,KAAa,EAAE,GAAQ,EAAE,iBAA0B,IAAI;QAC1D,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QAE1B,IAAI,cAAc,EAAE;YAChB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;SAC5D;IACL,CAAC;IAED,eAAe;IACf,SAAS,CAAC,KAAa;QACnB,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACvC,IAAI,QAAQ,KAAK,SAAS,EAAE;YACxB,OAAO,CAAC,IAAI,CAAC,8BAA8B,KAAK,qBAAqB,CAAC,CAAC;YACvE,OAAO;SACV;QACD,IAAI,QAAQ,KAAK,CAAC,EAAE;YAChB,OAAO,CAAC,IAAI,CAAC,8BAA8B,KAAK,kBAAkB,CAAC,CAAC;YACpE,OAAO;SACV;QAED,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,QAAQ,GAAG,CAAC,CAAC;QACrC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IAChC,CAAC;IAED,SAAS;QACL,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;QAClB,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;QACzB,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;IACxB,CAAC;IAED,eAAe;IACf,yBAAyB;QACrB,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;YAC/B,EAAE;YACF,0BAA0B;YAC1B,EAAE;YACF,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;gBAAE,OAAO;aAAE;YAE1C,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAEjC,EAAE;YACF,uEAAuE;YACvE,EAAE;YACF,IAAI,GAAG,YAAY,eAAM,EAAE;gBACvB,KAAK,MAAM,SAAS,IAAI,GAAG,CAAC,aAAa,CAAC,CAAC,MAAM,EAAE;oBAC/C,IAAI,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,KAAK,QAAQ;wBAC1D,GAAG,CAAC,SAAS,CAAC;wBACd,GAAG,CAAC,SAAS,CAAC,CAAC,UAAU,CAAC,EAAE;wBAC5B,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,CAAC;qBACpD;iBACJ;aAEJ;iBAAM;gBACH,MAAM,UAAU,GAAqB,GAAG,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,WAAW,CAAC;gBACxE,MAAM,IAAI,GAAG,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;gBAEtF,IAAI,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;oBAChD,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC;yBACnB,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;iBACpE;aACJ;YAED,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACxB,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACjC,CAAC,CAAC,CAAC;QAEH,sBAAsB;QACtB,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;IAC7B,CAAC;CAEJ;AAtFD,4CAsFC","sourcesContent":["import { Schema } from \"../Schema\";\nimport { Ref } from \"./ChangeTree\";\nimport type { SchemaDefinition } from \"../annotations\";\n\nexport class ReferenceTracker {\n    //\n    // Relation of refId => Schema structure\n    // For direct access of structures during decoding time.\n    //\n    public refs = new Map<number, Ref>();\n    public refCounts: { [refId: number]: number; } = {};\n    public deletedRefs = new Set<number>();\n\n    protected nextUniqueId: number = 0;\n\n    getNextUniqueId() {\n        return this.nextUniqueId++;\n    }\n\n    // for decoding\n    addRef(refId: number, ref: Ref, incrementCount: boolean = true) {\n        this.refs.set(refId, ref);\n\n        if (incrementCount) {\n            this.refCounts[refId] = (this.refCounts[refId] || 0) + 1;\n        }\n    }\n\n    // for decoding\n    removeRef(refId: number) {\n        const refCount = this.refCounts[refId];\n        if (refCount === undefined) {\n            console.warn(`trying to remove reference ${refId} that doesn't exist`);\n            return;\n        }\n        if (refCount === 0) {\n            console.warn(`trying to remove reference ${refId} with 0 refCount`);\n            return;\n        }\n\n        this.refCounts[refId] = refCount - 1;\n        this.deletedRefs.add(refId);\n    }\n\n    clearRefs() {\n        this.refs.clear();\n        this.deletedRefs.clear();\n        this.refCounts = {};\n    }\n\n    // for decoding\n    garbageCollectDeletedRefs() {\n        this.deletedRefs.forEach((refId) => {\n            //\n            // Skip active references.\n            //\n            if (this.refCounts[refId] > 0) { return; }\n\n            const ref = this.refs.get(refId);\n\n            //\n            // Ensure child schema instances have their references removed as well.\n            //\n            if (ref instanceof Schema) {\n                for (const fieldName in ref['_definition'].schema) {\n                    if (typeof (ref['_definition'].schema[fieldName]) !== \"string\" &&\n                        ref[fieldName] &&\n                        ref[fieldName]['$changes']) {\n                        this.removeRef(ref[fieldName]['$changes'].refId);\n                    }\n                }\n\n            } else {\n                const definition: SchemaDefinition = ref['$changes'].parent._definition;\n                const type = definition.schema[definition.fieldsByIndex[ref['$changes'].parentIndex]];\n\n                if (typeof (Object.values(type)[0]) === \"function\") {\n                    Array.from(ref.values())\n                        .forEach((child) => this.removeRef(child['$changes'].refId));\n                }\n            }\n\n            this.refs.delete(refId);\n            delete this.refCounts[refId];\n        });\n\n        // clear deleted refs.\n        this.deletedRefs.clear();\n    }\n\n}\n"]}